<!DOCTYPE html>
<html lang="en">
<head>
  <meta content="text/html; charset=UTF-8" http-equiv="content-type">
  <meta content="width=device-width, initial-scale=1" name="viewport">
  <title>animated line - update things</title>
  <!-- https://threejs.org/docs/#manual/en/introduction/How-to-update-things -->
  <style>
    body { margin: 0; }
  </style>
</head>
<body>

<script type="module">
  import * as THREE from "https://unpkg.com/three/build/three.module.js";

  const MAX_POINTS = 500;

  // renderer
  let renderer = new THREE.WebGLRenderer();
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // scene
  let scene = new THREE.Scene();

  // camera
  let camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);
  camera.position.set(0, 0, 1000);

  // geometry
  let geometry = new THREE.BufferGeometry();

  // attributes
  let positions = new Float32Array(MAX_POINTS * 3); // 3 vertices per point
  geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));

  // draw range (draw calls)
  let drawCount = 2; // draw the first 2 points, only
  geometry.setDrawRange(0, drawCount);

  // material
  let material = new THREE.LineBasicMaterial({ color: 0xff0000 });

  // line
  let line = new THREE.Line(geometry, material);
  scene.add(line);

  // update positions
  function updatePositions() {
    let positions = line.geometry.attributes.position.array;
    let x = 0;
    let y = 0;
    let z = 0;
    let index = 0;

    for (let i = 0, l = MAX_POINTS; i < l; i++) {
      positions[index++] = x;
      positions[index++] = y;
      positions[index++] = z;

      x += (Math.random() - 0.5) * 30;
      y += (Math.random() - 0.5) * 30;
      z += (Math.random() - 0.5) * 30;
    }
  }

  updatePositions();

  // animate
  function animate() {
    requestAnimationFrame(animate);

    drawCount = (drawCount + 1) % MAX_POINTS;

    line.geometry.setDrawRange(0, drawCount);

    if (drawCount === 0) {
      // periodically, generate new data
      updatePositions();

      line.geometry.attributes.position.needsUpdate = true; // required after the first render

      line.material.color.setHSL(Math.random(), 1, 0.5);
    }

    renderer.render(scene, camera);
  }

  animate();
</script>
</body>
</html>
