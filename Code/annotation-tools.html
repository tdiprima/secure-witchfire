<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <title>Annotation Tools</title>
  <link href="/css/main.css" rel="stylesheet">
</head>
<body>
<button id="rectangle">rectangle</button>
<button id="ellipse">ellipse</button>
<button id="polygon">polygon</button>
<script src="/build/three.min.js"></script>
<script>
  let scene, camera, renderer, updateMesh;
  let vertices;
  let segments;
  let typeOfShape;

  // Button event listeners
  let rectangle = document.getElementById("rectangle");
  let _ellipse = document.getElementById("ellipse");
  let polygon = document.getElementById("polygon");

  rectangle.addEventListener("click", function () {
    typeOfShape = "rectangle";
    initGeometry(); // Initialize geometry when button is clicked
  });

  _ellipse.addEventListener("click", function () {
    typeOfShape = "ellipse";
    initGeometry();
  });

  polygon.addEventListener("click", function () {
    typeOfShape = "polygon";
    points = []; // todo: clear any previous polygon
    initGeometry();
  });

  // Create a scene
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.z = 5;

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Create a mesh
  let mesh;
  let material = new THREE.LineBasicMaterial({ color: 0x00ff00 });
  let geometry = new THREE.BufferGeometry();
  let positions = [];

  // Set up geometry and "update" function
  function initGeometry() {
    console.log("initGeometry")
    switch (typeOfShape) {
      case "rectangle":
        vertices = new Float32Array(12); // 4 vertices * 3 coordinates (x, y, z)
        updateMesh = updateRectangle;
        break;
      case "ellipse":
        segments = 64; // Number of line segments used to approximate the mesh
        vertices = new Float32Array((segments + 1) * 3); // (segments + 1) vertices * 3 coordinates (x, y, z)
        updateMesh = updateEllipse;
        break;
      case "polygon":
        vertices = new Float32Array(positions);
        updateMesh = updatePolygon;
        break;
      default:
        console.log("Invalid polygon type");
        return; // Return if typeOfShape is invalid
    }

    geometry.setAttribute("position", new THREE.BufferAttribute(vertices, 3));
  }

  // Everything is a "LineLoop"
  mesh = new THREE.LineLoop(geometry, material);
  scene.add(mesh);

  // Handle mouse events
  let isDrawing = false;
  let startPoint;
  let endPoint;
  let points = []; // polygon

  renderer.domElement.addEventListener("mousedown", onMouseDown, false);
  renderer.domElement.addEventListener("mousemove", onMouseMove, false);
  renderer.domElement.addEventListener("mouseup", onMouseUp, false);
  renderer.domElement.addEventListener("dblclick", onDoubleClick, false);

  function onMouseDown(event) {
    event.preventDefault();
    isDrawing = true;
    startPoint = getMousePosition(event.clientX, event.clientY);
    points.push(startPoint);
  }

  function onMouseMove(event) {
    event.preventDefault();
    if (isDrawing) {
      endPoint = getMousePosition(event.clientX, event.clientY);
      points[points.length - 1] = endPoint;
      if (updateMesh) updateMesh();
    }
  }

  function onMouseUp(event) {
    event.preventDefault();
    if (typeOfShape !== "polygon") isDrawing = false;
    endPoint = getMousePosition(event.clientX, event.clientY);
    points.push(endPoint);
    if (updateMesh) updateMesh();
  }

  function onDoubleClick(event) {
    event.preventDefault();
    if (typeOfShape === "polygon") {
      if (isDrawing && points.length >= 3) {
        isDrawing = false;
        points.pop(); // Remove the duplicated point from double-click
        updatePolygon();
      }
    }
  }

  function getMousePosition(clientX, clientY) {
    let domRect = renderer.domElement.getBoundingClientRect();

    let mouse = new THREE.Vector2();
    mouse.x = ((clientX - domRect.left) / domRect.width) * 2 - 1;
    mouse.y = -((clientY - domRect.top) / domRect.height) * 2 + 1;

    let raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);

    let intersectionPoint = new THREE.Vector3();
    raycaster.ray.intersectPlane(new THREE.Plane(new THREE.Vector3(0, 0, 1)), intersectionPoint);

    return intersectionPoint;
  }

  const updateRectangle = function () {
    let positions = mesh.geometry.attributes.position.array;
    positions[0] = startPoint.x;
    positions[1] = startPoint.y;
    positions[2] = startPoint.z;
    positions[3] = endPoint.x;
    positions[4] = startPoint.y;
    positions[5] = startPoint.z;
    positions[6] = endPoint.x;
    positions[7] = endPoint.y;
    positions[8] = startPoint.z;
    positions[9] = startPoint.x;
    positions[10] = endPoint.y;
    positions[11] = startPoint.z;
    mesh.geometry.attributes.position.needsUpdate = true;
  }

  const updateEllipse = function () {
    let positions = mesh.geometry.attributes.position.array;
    let center = new THREE.Vector3().addVectors(startPoint, endPoint).multiplyScalar(0.5);
    let radiusX = Math.abs(startPoint.x - endPoint.x) * 0.5;
    let radiusY = Math.abs(startPoint.y - endPoint.y) * 0.5;

    for (let i = 0; i <= segments; i++) {
      let theta = (i / segments) * Math.PI * 2;
      let x = center.x + Math.cos(theta) * radiusX;
      let y = center.y + Math.sin(theta) * radiusY;
      positions[i * 3] = x;
      positions[i * 3 + 1] = y;
      positions[i * 3 + 2] = 0;
    }

    mesh.geometry.attributes.position.needsUpdate = true;
  }

  const updatePolygon = function () {
    // You need to update the vertices array whenever the points array changes.
    let numPoints = points.length;
    if (numPoints > 0) {
      positions = new Float32Array(numPoints * 3);
      for (let i = 0; i < numPoints; i++) {
        positions[i * 3] = points[i].x;
        positions[i * 3 + 1] = points[i].y;
        positions[i * 3 + 2] = points[i].z;
      }

      if (isDrawing) {
        positions[numPoints * 3] = points[0].x; // Connect the last point with the first point
        positions[numPoints * 3 + 1] = points[0].y;
        positions[numPoints * 3 + 2] = points[0].z;
      }
    }

    mesh.geometry.setAttribute("position", new THREE.Float32BufferAttribute(positions, 3));
    mesh.geometry.attributes.position.needsUpdate = true;
  }

  function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
  }

  animate();

  window.addEventListener("resize", () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
  });
</script>
</body>
</html>
