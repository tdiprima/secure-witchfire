<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta content="IE=edge" http-equiv="X-UA-Compatible">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <title>Combo</title>
  <style>
    body {
      margin: 0;
    }
  </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.144/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.144.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.144.0/examples/js/loaders/OBJLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.144.0/examples/js/loaders/MTLLoader.js"></script>
<script>
  console.log(`%cREVISION ${THREE.REVISION}`, "color: #ccff00;");
  let index = 0;
  let coords = new THREE.Vector3();
  let radius = 0.01;

  let scene = new THREE.Scene();
  scene.background = new THREE.Color(0xcfe2f3);

  let lights = new THREE.HemisphereLight();
  scene.add(lights);

  // let helper = new THREE.HemisphereLightHelper(light, 5);
  // scene.add(helper);

  // Camera parameters
  let fov = 45;
  let aspect = window.innerWidth / window.innerHeight;
  let near = radius / 2;
  let far = 1000 * radius;

  let camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
  camera.position.set(-0.007560464555714057, 0.5278398102814124, 0.3606677485446075);

  let renderer = new THREE.WebGLRenderer({antialias: true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  let controls = new THREE.OrbitControls(camera, renderer.domElement);

  // let objLoader = new THREE.OBJLoader();
  // objLoader.loadMtl("assets/flatland.mtl", null, materials => {
  //   objLoader.setMaterials(materials);
  //   objLoader.load("assets/flatland.obj", event => {
  //     let root = event.detail.loaderRootNode;
  //     scene.add(root);
  //   });
  // });

  new THREE.MTLLoader()
    .load("assets/flatland.mtl", function (materials) {
      materials.preload();
      new THREE.OBJLoader()
        .setMaterials(materials)
        .load("assets/flatland.obj", function (object) {
          scene.add(object);
        });
    });

  // LINE
  let geometry = new THREE.BufferGeometry();

  let positionAttribute = new THREE.BufferAttribute(new Float32Array(1000 * 3), 3); // allocate large enough buffer
  positionAttribute.setUsage(THREE.DynamicDrawUsage);
  geometry.setAttribute("position", positionAttribute);

  let material = new THREE.LineBasicMaterial({ color: 0xff00ff });

  line = new THREE.Line(geometry, material);
  scene.add(line);

  // initial points
  addPoint(0, 0, 0); // start point
  addPoint(1, 0, 0); // current pointer coordinate

  renderer.domElement.addEventListener('pointerdown', onPointerDown);
  renderer.domElement.addEventListener('pointermove', onPointerMove);

  window.addEventListener("resize", onWindowResize, false);

  animate();

  function addPoint(x, y, z) {
    const positionAttribute = line.geometry.getAttribute('position');
    positionAttribute.setXYZ(index, x, y, z);
    positionAttribute.needsUpdate = true;

    index++;

    line.geometry.setDrawRange(0, index);
  }

  function updatePoint(x, y, z) {
    const positionAttribute = line.geometry.getAttribute('position');
    positionAttribute.setXYZ(index - 1, coords.x, coords.y, 0);
    positionAttribute.needsUpdate = true;
  }

  function onPointerDown(event) {
    coords.x = (event.clientX / window.innerWidth) * 2 - 1;
    coords.y = -(event.clientY / window.innerHeight) * 2 + 1;
    // coords.z = (camera.near + camera.far) / (camera.near - camera.far);

    // coords.unproject(camera);

    addPoint(coords.x, coords.y, 0);

    renderer.render(scene, camera);
  }

  function onPointerMove(event) {
    coords.x = (event.clientX / window.innerWidth) * 2 - 1;
    coords.y = -(event.clientY / window.innerHeight) * 2 + 1;
    // coords.z = (camera.near + camera.far) / (camera.near - camera.far);

    // coords.unproject(camera);

    updatePoint(coords.x, coords.y, 0);

    renderer.render(scene, camera);
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.render(scene, camera);
  }

  function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
  }
</script>
</body>
</html>
